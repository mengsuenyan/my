use crate::cmd::args::{IOArgs, Key, KeyArgs, Salt, SaltArgs};
use crate::cmd::config::MyConfig;
use crate::cmd::hash::HashSubCmd;
use cipher::rsa::{PSSSign, PSSVerify, PrivateKey, PublicKey};
use cipher::{CipherError, DefaultRand, Sign, Verify};
use clap::{Args, Subcommand};
use num_bigint::BigUint;
use num_traits::{Num, ToBytes};
use std::io::Write;

#[derive(Args)]
#[command(about = "RSA Signer")]
pub struct RsaArgs {
    #[command(subcommand)]
    sub_cmd: RsaSubArgs,
}

#[derive(Subcommand)]
pub enum RsaSubArgs {
    #[command(name = "pssv")]
    PssVerify(PSSVerifyArgs),
    #[command(name = "psss")]
    PssSign(PSSSignArgs),
}

#[derive(Args)]
#[command(about = r#"Verify(PIPE | STRING | file)
RFC 8017
PKCS #1: RSA Cryptography Specification Version 2.2
PSS(Probabilistic Signature Scheme)
"#)]
#[command(mut_arg("ofile", |a| a.hide(true)))]
#[command(mut_arg("replace", |a| a.hide(true)))]
#[command(mut_group("key", |g| g.required(true)))]
#[command(mut_group("salt", |g| g.id("sig").required(true)))]
#[command(mut_arg("kfile", |a| a.help("the key file that generated by the `my key rsa` with no `--0x` parameter")))]
#[command(mut_arg("kstr", |a| a.help("the hex public key string generated by the `my key rsa --0x`")))]
#[command(mut_arg("sfile", |a| a.value_name("SIGNATURE").help("the non-hex signature file path")))]
#[command(mut_arg("sstr", |a| a.value_name("SIGNATURE").help("the hex signature string")))]
pub struct PSSVerifyArgs {
    #[arg(value_name = "STRING")]
    msg: Option<String>,

    #[command(flatten)]
    io: IOArgs,

    #[command(flatten)]
    key: KeyArgs,

    #[command(flatten)]
    sig: SaltArgs,

    #[command(subcommand)]
    h: HashSubCmd,
}

#[derive(Args)]
#[command(about = r#"Sign(PIPE | STRING | file)
RFC 8017
PKCS #1: RSA Cryptography Specification Version 2.2
PSS(Probabilistic Signature Scheme)
"#)]
#[command(mut_arg("ofile", |a| a.hide(false).value_name("SIGNATURE").help("the output signature file path")))]
#[command(mut_arg("replace", |a| a.hide(false)))]
#[command(mut_group("sig", |g| g.required(false)))]
#[command(mut_arg("sfile", |a| a.hide(true)))]
#[command(mut_arg("sstr", |a| a.hide(true)))]
pub struct PSSSignArgs {
    #[command(flatten)]
    pss: PSSVerifyArgs,

    #[arg(long = "0x", help = "output in the hex format")]
    prefix: bool,
}

impl RsaArgs {
    pub fn exe(self, pipe: Option<&[u8]>) {
        match self.sub_cmd {
            RsaSubArgs::PssVerify(a) => a.exe(pipe),
            RsaSubArgs::PssSign(a) => a.exe(pipe),
        }
    }

    pub fn private_key(key_args: &KeyArgs) -> anyhow::Result<PrivateKey> {
        let key = Key::try_from(key_args).unwrap().to_bytes();
        let json: serde_json::Value = serde_json::from_slice(key.as_slice()).unwrap();
        let key: PrivateKey = if key_args.kstr.is_some() {
            let (d, p, q) = (
                json["d"].to_string(),
                json["factor"]["p"].to_string(),
                json["factor"]["q"].to_string(),
            );
            let (d, p, q) = (
                Self::convert_hex(d.into_bytes()),
                Self::convert_hex(p.into_bytes()),
                Self::convert_hex(q.into_bytes()),
            );
            PrivateKey::new_uncheck_with_factor(d, p, q, vec![])
        } else {
            serde_json::from_value(json).unwrap()
        };

        Ok(key)
    }

    pub fn public_key(key_args: &KeyArgs) -> anyhow::Result<PublicKey> {
        let key = Key::try_from(key_args)?.to_bytes();
        let json: serde_json::Value = serde_json::from_slice(key.as_slice())?;

        let key: PublicKey = if key_args.kstr.is_some() {
            let (n, e) = (json["pk"]["n"].to_string(), json["pk"]["e"].to_string());
            let (n, e) = (
                Self::convert_hex(n.into_bytes()),
                Self::convert_hex(e.into_bytes()),
            );
            PublicKey::new_uncheck(n, e)
        } else {
            serde_json::from_value(json["pk"].clone())?
        };

        Ok(key)
    }

    fn convert_hex(data: Vec<u8>) -> BigUint {
        if data.len() > 2 {
            let data = String::from_utf8(data)
                .unwrap()
                .trim_matches('"')
                .to_string();
            if &data[..2] == "0x" || &data[..2] == "0X" {
                BigUint::from_str_radix(&data[2..], 16).unwrap()
            } else {
                BigUint::from_str_radix(&data, 16).unwrap()
            }
        } else {
            BigUint::from_bytes_be(&data)
        }
    }
}

impl PSSVerifyArgs {
    pub fn exe(self, pipe: Option<&[u8]>) {
        let hasher = self.h.hasher().unwrap();
        let data = self.parse_data(pipe);

        let mut sig = Salt::try_from(&self.sig).unwrap().to_bytes();
        if self.sig.sstr.is_some() {
            sig = RsaArgs::convert_hex(sig).to_be_bytes();
        }

        let key = RsaArgs::public_key(&self.key).unwrap();
        let mut pss = PSSVerify::new(key, hasher, None).unwrap();
        match pss.verify(data.as_slice(), sig.as_slice()) {
            Ok(()) => {
                println!("Validation success.");
            }
            Err(CipherError::ValidateFailed(e)) => {
                eprintln!("{e}");
            }
            Err(e) => panic!("{e}"),
        }
    }

    fn parse_data(&self, pipe: Option<&[u8]>) -> Vec<u8> {
        let mut data = MyConfig::tmp_buf();

        if let Some(pipe) = pipe {
            data.extend_from_slice(pipe);
        }

        if let Some(msg) = self.msg.as_deref() {
            data.extend_from_slice(msg.as_bytes());
        }

        if let Some(mut f_data) = self.io.read_all_data().unwrap() {
            data.append(&mut f_data);
        }

        data
    }
}

impl PSSSignArgs {
    pub fn exe(self, pipe: Option<&[u8]>) {
        let hasher = self.pss.h.hasher().unwrap();
        let data = self.pss.parse_data(pipe);

        let key = RsaArgs::private_key(&self.pss.key).unwrap();
        let rd = DefaultRand::default();
        let mut sig = Vec::with_capacity((key.public_key().modules().bits() as usize + 7) >> 3);
        let mut pss = PSSSign::new(key, hasher, rd, None).unwrap();
        pss.sign(data.as_slice(), &mut sig).unwrap();

        let mut writer = self.pss.io.writer_with_default(sig.len()).unwrap();
        if self.prefix {
            let sig = format!("{:#x}", BigUint::from_bytes_be(&sig));
            writer.write_all(sig.as_bytes()).unwrap()
        } else {
            writer.write_all(&sig).unwrap()
        }
    }
}
